jsoniq version "1.0";

(:
 : Copyright 2012-2015 28msec Inc.
 :)

(:~
 : <p>This module provides functionality for importing archives (JSON or XBRL).</p>
 :
 : @author Federico Cavalieri
 :)
module namespace xbrl-import = "http://28.io/modules/xbrl/import";

import module namespace http = "http://zorba.io/modules/http-client";
import module namespace archive = "http://zorba.io/modules/archive";

import module namespace config = "http://apps.28.io/config";
import module namespace api = "http://apps.28.io/api";

import module namespace archives = "http://28.io/modules/xbrl/archives";
import module namespace entities = "http://28.io/modules/xbrl/entities";


import module namespace dsw = "http://28.io/modules/xbrl/data-source-wrapper";

declare %an:sequential function xbrl-import:insert-infoset-archive($archive as atomic, 
                                                                   $insert-entity as boolean) as empty-sequence()
{
  try
  {{
    let $archives as object+ := 
      api:extract-from-compressed-archive($archive, "archives.json", true)
    let $components as object* := 
      api:extract-from-compressed-archive($archive, "components.json", false)
    let $concepts as object* := 
      api:extract-from-compressed-archive($archive, "concepts.json", false)
    let $entities as object+:= 
      api:extract-from-compressed-archive($archive, "entity.metadata", true)
    let $facts as object* := 
      api:extract-from-compressed-archive($archive, "facts.json", false)
    let $footnotes as object* := 
      api:extract-from-compressed-archive($archive, "footnotes.json", false)
    return
    {
      for $entity in $entities
      where empty(entities:entities($entity._id))
      return 
        if ($insert-entity)
        then dsw:insert("entities", $entity);
        else error(QName("xbrl-import:ENTITY-DOES-NOT-EXIST"), 
                   "Entity \"" || $entity._id || "\" is not present in the cellstore");

      dsw:insert("archives", $archives);
      dsw:insert("components", $components);
      dsw:insert("concepts", $concepts);
      dsw:insert("entities", $entities);
      dsw:insert("facts", $facts);
      dsw:insert("footnotes", $footnotes);
    }
  }}
  catch archive:CORRUPTED-ARCHIVE
  {
    error(QName("xbrl-import:INFOSET-ARCHIVE"), 
          "Archive generated by the infoset-generator cannot be extracted: "  || $err:description);
  }
  catch api:EXTRACTION
  {
    error(QName("xbrl-import:INFOSET-ARCHIVE"), 
          "Archive generated by the infoset-generator cannot be extracted: "  || $err:description);  
  }
};

declare function xbrl-import:endpoint($profile-name as string, 
                                      $taxonomy as boolean, 
                                      $archive-id as string) as string
{
  if (
       matches($config:infoset-generator-url, 
               "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}(:[0-9]{1,5})?$") or
       matches($config:infoset-generator-url, 
               "(^([a-zA-Z0-9_\\-]{1,63}\\.?)+([a-zA-Z]{2,})(:[0-9]{1,5})?$)")
     )
  then
    "http://" || $config:infoset-generator-url || "/v1/filings?profile=" || encode-for-uri($profile-name) ||
      (if ($taxonomy) then "&taxonomy=true" else "&taxonomy=false") ||
      "&archiveId=" || encode-for-uri($archive-id)
  else if ($config:infoset-generator-url eq "")
  then error(QName("xbrl-import:INVALID-INFOSET-ENDPOINT"), "Infoset generator endpoint is not configured")
  else error(QName("xbrl-import:INVALID-INFOSET-ENDPOINT"), "Infoset generator endpoint is invalid")
};

declare %an:sequential function xbrl-import:process-xbrlx-archive($xbrlx-archive as base64Binary, 
                                                                  $profile-name as string, 
                                                                  $taxonomy as boolean, 
                                                                  $archive-id as string) as base64Binary
{
  try
  {{
    if (empty(archive:entries($xbrlx-archive)))
    then error(QName("xbrl-import:XBRLX-ARCHIVE"), "Provided XBRLX archive is empty.");
    else ();
  }}
  catch archive:CORRUPTED-ARCHIVE
  {
    error(QName("xbrl-import:XBRLX-ARCHIVE"), 
          "Provided XBRLX archive cannot be extracted: "  || $err:description);
  }
    
  variable $url := xbrl-import:endpoint($profile-name, $taxonomy, $archive-id);
  try
  { 
    let $response := http:send-request(
      {
        "href": $url,
        "method": "POST",
        "body":
        {
          "media-type": "application/xbrlx",
          "content": $xbrlx-archive
        }
      })
    return
      if ($response.status eq 200)
      then
      {
        let $processed-archive := $response.body.content
        return
            if ($processed-archive instance of base64Binary)
            then $processed-archive
            else error(QName("xbrl-import:INFOSET-GENERATOR"), 
                       "Unexpected infoset generator reply: "  || string($processed-archive))
      }
      else 
      {
        error(QName("xbrl-import:CONVERSION"), 
              "An error occurred during the conversion of the xbrlx filing: "  || string($response.body.content))
      }
  }
  catch http:*
  {
    error(QName("xbrl-import:INFOSET-GENERATOR"), 
          "Cannot connect to the infoset generator (" || $url || "): " ||  $err:description)
  }
};
