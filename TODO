CodeFormatter was run on all tests in tests/queries/xqlint that have a .xq and accompanying .txt file,
the functx function library, and the Try Zorba examples (excluding XQuery Modules). Except for points
1-4 below, these inputs should be formatted properly.


Issues/Todos: 

1. Comments are not fully supported yet: They are only properly formatted when they are within an
ignoreNode and don't interfere with postNewLine()s. It is necessary to pre-process the ast and move 
the WS nodes containing comments to the correct node. Then it is possible to e.g. post a newline
after clauses in a FLWORExpr.

Example:
let $x := 1 (: comment within a flwor :)
(: another one :) return $x

Formats to:
let $x := 1
(: comment within a flwor :) (: another one :) return $x


The first comment is not part of the LetClause, and the LetClause formatting rule posts a newline after.
Thus the first comment incorrectly gets written on the second line. 



2. XML Nodes are not formatted yet, they are written as-is. The opening tag starts at the same
column as in the input, if the tag is put on its own line.

Example:
  let $works := <works>
      <employee name="1" />
	...

Formats to:
let $works := 
	      <works>
      <employee name="1" />
        ...

<works> is on a new line because the Expr on the right-hand-side of the LetBinding is multiline. 
If we don't format xml nodes, we could e.g. put the top-level starting tag on the same position 
as the top-level closing tag. A problem with not formatting xml nodes, as also seen above, is 
that the indentation of it is with respect to the other content, which might get formatted 
differently by the formatter. 


3. Wrapping of content on the far right is not properly implemented yet. Adding a lot of rules 
like in LetBinding (check if right-hand-side can be written on one line without wrapping, if not
preemptively pushindent and insert a newline) seems to be a good way to avoid far-right content. 


4. As of now, one-line formatting for certain nodes (e.g. a ReturnClause) is only applied if the
input is also on one line.
E.g. 

if ($a) then $b else $c
    
is left as is, while 

if ($a) then $b else
$c 

is formatted to 

if ($a) then
  $b
else
  $c

because the input is not on one line. 

WS in the AST after certain nodes messes this up, e.g.

for $i in (let, for)
return return

is formatted to

for $i in (let, for)
return
    return

because of a '\n' being part of the ReturnClause. Could be fixed by removing WS that have no
semantic impact from the end of nodes (and moving it to the parent node). 



5. The following nonterminals have no explicit formatting rule on the top-level yet. The list
is the diff of the currently present top-level formatting rules in CodeFormatter and the
complete list of XQUery nonterminals. Nonterminals that are not intended to have one are not 
filtered out.

Module, LibraryModule, BoundarySpaceDecl, DefaultCollationDecl, BaseURIDecl, 
ConstructionDecl, OrderingModeDecl, EmptyOrderDecl, CopyNamespacesDecl, PreserveMode, 
InheritMode, DecimalFormatDecl, DFPropertyName, SchemaImport, SchemaPrefix, ModuleImport, 
CompatibilityAnnotation, VarDecl, VarValue, VarDefaultValue, FunctionBody, EnclosedExpr, 
InitialClause, IntermediateClause, ForClause, AllowingEmpty, PositionalVar, FTScoreVar, 
WindowClause, WindowVars, CurrentItem, PreviousItem, NextItem, CountClause, WhereClause, 
GroupByClause, GroupingSpecList, GroupingSpec, OrderByClause, OrderSpecList, OrderSpec, 
OrderModifier, QuantifiedExpr, SwitchCaseOperand, SequenceTypeUnion, TryTargetExpr, 
CatchErrorList, OrExpr, AndExpr, FTContainsExpr, StringConcatExpr, RangeExpr, UnionExpr, 
IntersectExceptExpr, InstanceofExpr, TreatExpr, CastableExpr, CastExpr, UnaryExpr, 
ValueExpr, SimpleMapExpr, GeneralComp, ValueComp, NodeComp, ValidateExpr, ValidationMode, 
ExtensionExpr, Pragma, PathExpr, RelativePathExpr, StepExpr, AxisStep, ForwardStep, 
ForwardAxis, AbbrevForwardStep, ReverseStep, ReverseAxis, AbbrevReverseStep, NodeTest, 
NameTest, PostfixExpr, PredicateList, Predicate, Literal, NumericLiteral, VarRef, VarName, 
ContextItemExpr, OrderedExpr, UnorderedExpr, Argument, ArgumentPlaceholder, Constructor, 
DirectConstructor, DirAttributeList, DirAttributeValue, QuotAttrValueContent, 
AposAttrValueContent, DirElemContent, DirCommentConstructor, DirPIConstructor, 
ComputedConstructor, CompNamespaceConstructor, Prefix, PrefixExpr, URIExpr, 
FunctionItemExpr, NamedFunctionRef, InlineFunctionExpr, SingleType, TypeDeclaration, 
SequenceType, OccurrenceIndicator, ItemType, StructuredItemTest, JSONItemTest, 
JSONObjectTest, JSONArrayTest, AtomicOrUnionType, KindTest, AttribNameOrWildcard, 
AttributeDeclaration, ElementNameOrWildcard, ElementDeclaration, AttributeName, ElementName, 
SimpleTypeName, TypeName, FunctionTest, AnyFunctionTest, TypedFunctionTest, 
ParenthesizedItemType, RevalidationDecl, InsertExprTargetChoice, InsertExpr, DeleteExpr, 
ReplaceExpr, RenameExpr, SourceExpr, TargetExpr, NewNameExpr, TransformExpr, FTSelection, 
FTWeight, FTOr, FTAnd, FTMildNot, FTUnaryNot, FTPrimaryWithOptions, FTPrimary, FTWords, 
FTWordsValue, FTExtensionSelection, FTAnyallOption, FTTimes, FTRange, FTPosFilter, FTOrder, 
FTWindow, FTDistance, FTUnit, FTScope, FTBigUnit, FTContent, FTMatchOptions, FTMatchOption, 
FTCaseOption, FTDiacriticsOption, FTStemOption, FTThesaurusOption, FTThesaurusID, FTLiteralRange, 
FTStopWordOption, FTStopWords, FTStopWordsInclExcl, FTLanguageOption, FTWildCardOption, 
FTExtensionOption, FTIgnoreOption, CollectionDecl, CollectionTypeDecl, IndexName, IndexDomainExpr, 
IndexKeySpec, IndexKeyExpr, IndexKeyTypeDecl, AtomicType, IndexKeyCollation, IndexDecl, ICDecl, 
ICCollection, ICCollSequence, ICCollSequenceUnique, ICCollNode, ICForeignKey, ICForeignKeySource, 
ICForeignKeyTarget, ICForeignKeyValues, Whitespace, EQName, FunctionName, NCName, MainModule, 
Program, StatementsAndExpr, SwitchCaseStatement, CaseStatement, ExprSingle, ExprSimple, 
JSONDeleteExpr, JSONInsertExpr, JSONRenameExpr, JSONReplaceExpr, JSONAppendExpr, CommonContent, 
CompDocConstructor, CompAttrConstructor, CompPIConstructor, CompCommentConstructor, 
CompTextConstructor, PrimaryExpr, JSONSimpleObjectUnion, PragmaContents, DirCommentContents, 
DirPIContents, CDataSection, CDataSectionContents, Wildcard, URIQualifiedName, BracedURILiteral, 
URILiteral, IntegerLiteral, DecimalLiteral, DoubleLiteral, StringLiteral, PredefinedEntityRef, 
EscapeQuot, EscapeApos, ElementContentChar, QuotAttrContentChar, AposAttrContentChar, PITarget, 
Name, NameStartChar, NameChar, Char, QName, PrefixedName, UnprefixedName, LocalPart, CharRef, 
Digits, CommentContents, NonNCNameChar, DelimitingChar
